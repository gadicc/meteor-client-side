var gunzip = Meteor.npmRequire('gunzip-maybe');
var tar = Meteor.npmRequire('tar-stream');
var https = Npm.require('https');
var Fiber = Npm.require('fibers');

var packages = new Mongo.Collection('packages');
//packages.remove({});

// Note: we call update() on a notFound too
var updatePackages = _.throttle(packageServer.update, 10000);
//Meteor.setInterval(updatePackages, 60000);

function resEnd(res, buffer) {
  res.writeHead(200, 'OK', {
    'content-type': 'application/javascript',
    'cache-control': 'max-age=3155692'
  });

  res.end(buffer, 'utf8');
}

var supportedFormats = ['unipackage-unibuild-pre1'];

function wrap(packageData) {
  //var x = _.clone(packageData);
  //if (x.unminified) x.unminified = true;
  //if (x.webBrowserJson) x.webBrowserJson = true;
  var pre = '/* Generated by csp.meteor.com */\n\n' +
    '(function () {\n\n';
  var post = '\n\n/* Exports */\n' +
    "if (typeof Package === 'undefined') Package = {};\n" +
    "Package['" + packageData.packageName + "'] = {\n";

  var webData = packageData.webBrowserJson;

  if (webData.uses && webData.uses.length) {
    pre += '/* Imports */\n';
    _.each(webData.uses, function(dep) {
      if (!dep.weak) {
        // Ok, we fucked up.  This approach won't work since the imports depend on
        // the version used.  But for now, to get a head start, let's just use the
        // latest version and hope for the best.  THIS WILL BREAK if the version
        // has picked version has different exports to what we want / expect from
        // correct version.
        //var pack2 = 
      }
    });
  }


  if (supportedFormats.indexOf(webData.format) === -1) {
    // console.log(webData);
    throw new Error('Unsupported format: ' + packageData.format);
  }

  if (webData.packageVariables && webData.packageVariables.length) {
    pre += '/* Package-scope variables */\nvar ';

    _.each(webData.packageVariables, function(variable) {
      pre += variable.name + ', ';
      if (variable.export)
        post += '  ' + variable.name + ': ' + variable.name + ',\n';
    });

    pre = pre.substr(0, pre.length - 2) + ';\n\n';
  }
  post = post.substr(0, post.length - 2) + '\n};\n\n})();\n';

  // console.log(packageData.webBrowserJson);

  return pre + packageData.unminified + post;
}

retrievePackage = function(packageData) {
  var fiber = Fiber.current;
  var extract = tar.extract();

  var existing = packages.findOne(packageData);
  if (existing) {
    // console.log(packageData.packageName + ' (from db)');
    return existing;
  }

  console.log(packageData.packageName + ' (starting retrieval)');
  var version = packageServer.versions.findOne(packageData);

  if (!version) {
    console.log('* not found.');
    res.writeHead(404, 'Not Found');
    res.end();
    Fiber(updatePackages).run();
    return;
  }

  var build = packageServer.builds.findOne({ versionId: version._id });
  if (!build) {
    res.writeHead(500, 'Internal error');  // I guess it's also 404, but weird case
    res.end();
    return;
  }

  var storeAndRun = function(packageData) {
    /*
    var x = _.clone(packageData);
    if (x.unminified) x.unminified = true;
    console.log(x);
    */

    if (!(packageData.hasOwnProperty('unminified')
        && packageData.hasOwnProperty('webBrowserJson')))
      return;

    console.log(packageData.packageName + ' (finished retrieval)');

    packageData.webBrowserJson = JSON.parse(packageData.webBrowserJson);

    Fiber(function() {
      packages.insert(packageData);
    }).run();

    fiber.run(packageData);
  };

  extract.on('entry', function(header, stream, next) {

    // more checks?
    // 'gadicohen_famous-views-1.2.0/web.browser/packages/gadicohen_famous-views.js',

    var what = null;
    var buffer = '';

    if (header.name.match(/^[^\/]+\/web\.browser\/packages\/[^\.]+\.js$/))
      what = 'unminified';
    else if (header.name.match(/^[^\/]+\/web\.browser\.json$/))
      what = 'webBrowserJson';

    if (what) {

      stream.on('data', function(chunk) {
        buffer += chunk.toString('utf8');
      });

      stream.on('end', function() {
        // console.log('end of ' + what);
        packageData[what] = buffer;
        storeAndRun(packageData);
        next();
      });
    
    } else {

      stream.on('end', next);

    }

    stream.resume();

  });

  https.get(build.build.url, function(res) {
    res.pipe(gunzip()).pipe(extract);
  });

  return Fiber.yield();
}

var re = /^\/([^@]+)@(.*?)\.js$/;
WebApp.connectHandlers.use(function(req, res, next) {
  var match = re.exec(req.url);
  if (!match)
    return next();

  console.log(req.url);

  var packageName = match[1];
  var version = match[2];

  var packageData = {
    packageName: packageName,
    version: version
  };

  packageData = retrievePackage(packageData);
  
  resEnd(res, wrap(packageData));
});